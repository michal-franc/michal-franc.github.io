---
layout: post
title: FluentNHibernate , NHibernate–Notes
date: 2011-03-30 22:30:36.000000000 +01:00
categories: []
tags:
- FluentNH
- NHibernate
status: publish
type: post
published: true
meta:
  jabber_published: '1301524237'
  reddit: a:2:{s:5:"count";s:1:"0";s:4:"time";s:10:"1306792202";}
  dsq_thread_id: '352115026'
  _edit_last: '1'
  _yoast_wpseo_linkdex: '0'
author:
  login: LaM
  email: lam.michal.franc@gmail.com
  display_name: Michal Franc
  first_name: Michal
  last_name: Franc
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p align="justify">I m currently implementing some project using the NHibernate. I dont like the mappongs stored in xml files so I am using FluentNhiberante.</p>
<p align="justify">
<h5 align="justify">1. Mapping Whole Assembly.</h5>
<p align="justify">Before discovering this feature , I created one line foreach mapping defined in the assembly. You can replace this “useless” code with the procedure to map whole assembly. FluentNH  will scan the assembly and look for classes inheriting from ClassMap&lt;&gt;</p>
<pre class="lang:default decode:true"> return Fluently.Configure().
    Database(MsSqlConfiguration.MsSql2008.ConnectionString("connstring"))
      .Mappings(x =&gt; x.FluentMappings.AddFromAssembly(System.Reflection.Assembly.GetExecutingAssembly()))
      .ExposeConfiguration(func)
      .BuildSessionFactory();</pre>
<p>&nbsp;</p>
<h5 align="justify">2. not null fields</h5>
<p align="justify">If you want to create some fields in the DB as “not null”. use the Not.Nullable() sequence.</p>
<pre class="lang:default decode:true">Map(x =&gt; x.IDCourse).Not.Nullable();</pre>
<p>&nbsp;</p>
<h5 align="justify">3. Reseting Schema for Testing</h5>
<p align="justify">I don’t know if this is a good approach but when , I am working with NH i create an instance of test database with sample data. Everytime , I am running tests i m reseting schema , filling DB with sample data and then database is erased from memory (SQLite) or the server.</p>
<p align="justify"><strong>Session Factory Class</strong></p>
<p align="justify">In my session factory Class i have methods to reset and update Schema</p>
<p align="justify">
<pre class="lang:default decode:true crayon-selected"> public static class SessionFactory
{
    public static ISession OpenSession()
    {
        return GetSessionFactory().OpenSession();
    }
     private static ISessionFactory GetSessionFactory()
     {
        if (_sessionFactory == null)
        {
            _sessionFactory = CreateSessionFactory(UpdateSchema);
         }
         return _sessionFactory;
     }
        private static ISessionFactory _sessionFactory;

        public static void ResetSchema()
        {
            CreateSessionFactory(ResetSchema);
        }

        private static ISessionFactory CreateSessionFactory(Action&lt;Configuration&gt; func)
        {

          return Fluently.Configure().
               Database(MsSqlConfiguration.MsSql2008.ConnectionString
               ("connstring"))
               .Mappings(x =&gt; x.FluentMappings.AddFromAssembly(System.Reflection.Assembly.GetExecutingAssembly()))
               .ExposeConfiguration(func)
               .BuildSessionFactory();
        }
        private static void UpdateSchema(Configuration config)
        {
            new SchemaUpdate(config).Execute(true, true);
        }

        public static void ResetSchema(Configuration config)
        {
            new SchemaExport(config).Create(true, true);
        }</pre>
<p>&nbsp;</p>
<p align="justify"><strong>4. Generic Repository</strong></p>
<p align="justify">I am the fan of the repositories used to perform all the CRUD and complex query operations. In the code I have a base repository class and complex repositories deriving from the base class.</p>
<pre class="lang:default decode:true">public  class Repository&lt;T&gt; : IRepository&lt;T&gt;
        where T : class
    {
        public T GetById(int id)
        {
            T klient;

            klient = GetByFilter("Id",id).FirstOrDefault();

            return klient;
        }

        public IList&lt;T&gt; GetByFilter(string parameterName, object value)
        {
            IList&lt;T&gt; returnedList = null;
            using (var session = SessionFactory.OpenSession())
            {
                returnedList = session.CreateCriteria(typeof(T)).Add(Expression.Eq(parameterName, value)).List&lt;T&gt;();
                session.Flush();
            }
            return returnedList;
        }

        protected IList&lt;T&gt; GetByQuery(string query)
        {
            IList&lt;T&gt; returnedList = null;
            using (var session = SessionFactory.OpenSession())
            {
                returnedList = session.CreateQuery(query).List&lt;T&gt;();
                session.Flush();
            }
            return returnedList;
        }

      .....

    }</pre>
<p align="justify">Simple Repository used for most CRUD operations.</p>
<p align="justify">For more complex queries , I just create a new class deriving from the base one.</p>
<pre class="lang:default decode:true">    public class KlientRepository : Repository&lt;Klient&gt;
    {
        public Klient GetByImieNazwisko(string imie, string nazwisko)
        {
            return GetByQuery(String.Format("from Klient k where k.Imie = '{0}' and k.Nazwisko = '{1}'",imie,nazwisko)).FirstOrDefault();
        }

        public IList&lt;Klient&gt; GetByRodzaj(string rodzaj)
        {
            return GetByQuery(String.Format("from Klient k where k.Rodzaj.Rodzaj = '{0}' ", rodzaj)).ToList();

        }
    }</pre>
<p>&nbsp;</p>
