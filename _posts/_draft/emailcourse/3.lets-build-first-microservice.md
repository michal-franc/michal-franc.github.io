Building distributed systems wiht .NET, Docker and Microservices

This post is part of series about building.

Today we will build a simple microservice and explore the meaning of what really microservice is. Next blog post will be about hosting.

#### Microservice

What is a microservice?
This will be in previous post.

#### First simple Microservice using Asp.NET Core server

Ok lets do this!

Beacuse I do encourage everyone to use console. That is what we will do today. Use the console and cli tools to work with .NET Core and create projects, build, run, test etc.

#### Windows 

If you are on Mac just ignore two next sections. Mac, Unix should be a lot simpler to use, and I assume you are already able to brew or apt-get Node :D

##### Installing command line replacement

Default cmd.exe in Windows is ok but it is not great. I always advise to install a better replacement there are many different options.

* [cmder (my choice)][3]
* [ConEmu][4]
* [babun][5]

##### Installing Node on Windows using chocolatey

* [Getting chocolatey][1]
* [Node with chocolatey][2]
* [.NET Core SDK][6] - this one is important, there were a lot of changes, I had old version that was incopatible with 'new-old' csproj files. <3 Microsot.

##### Installing yeoman and Bower and Generator

Yeoman is a templating engine erator.

```
npm install -g yo
```

Bower - a tool ""

```
npm install -g bower
```

Generator - then we need to install generator - [Omnisharp team is manintaing][0]. This one is maintaned by Omnisharp team.
```
npm install -g generator-aspnet
```

Testing the generator

```
yo aspnet console ConsoleTest
```

This generates basic Console App in ConsoleTest folder with Program.cs file and csproj and other cool stuff. Main function does contain a Console.WriteLine so we can easilly test it.

Dotnet cli provides nice tooling.

```
dotnet restore
dotnet build
dotner run
```

<gif with console command> - make it again to include new folder ConsoleTest

#### Hello World Microservice using Asp.net Core

```
yo aspnet web NetMicro
```

This one generated very simple self hosted app. Restoring and running it will run a self hosted server that binds to 5000 port and returns Hello World Message.

<gif with web micro gif>

#### Core Blocks of Microservices

<image of microservice as a hexagon>

In this blog post we will cover:

* Core
* Endpoint
* HealthCheck
* Logging

More blog posts to come in the future, covering rest of the modules.

* adding Monitoring
* adding Management
* adding Registry

We have a basic app now. MVC was not even added, let's start with this one as it is not that straight-forward.

```
snippets showing how to add mvc to project
```

With mvc we can add first basic controller that has core logic. This will be our main endpoint and core logic in itself. 

```
Controller
```

<gif with test>

With complex services we would have layers of services, logic, classess etc. This one is very simple.

#### Logging

Every app should have some logging. This is the only way to analyze failures, errors and 'debug' problems that we weren't able to predict. Every software is buggy and 'broken' a bit.

In .NET there are two popular solutions. Much older log4net and a bit younger NLog. I prefer NLog and use log4net only if there are some libraries, packages that also require it. There are subtle difference beetwen those two but in the end they provide very similar functionality.

Adding NLog package.

Saddly nuget CLI doesn't provide ability to add packages so that a csproj file is modified.

> The install command does not modify a project file or packages.config; in this way it's similar to restore in that it only adds packages to disk but does not change a project's dependencies. - https://docs.microsoft.com/en-us/nuget/tools/nuget-exe-cli-reference#install

?? What? Ok nevermind, this is a bit confusing.

Not sure why such a decision but ok lets do this manually.

Inside NetMicro.csproj we need to add new lines. At the time of this writing there was NLog version 5.0.0-betax compatible with the .NET Core. Check this link and see if there is a never version. We also need NLog.Extensions.Logging lib that provides a NLog Middleware ?? ( I think check it )

https://www.nuget.org/packages/NLog/
https://www.nuget.org/packages/NLog.Extensions.Logging/

```
    <PackageReference Include="Microsoft.AspNetCore" Version="1.0.4" />
    <PackageReference Include="Microsoft.AspNetCore.Mvc" Version="1.1.2" />
    <PackageReference Include="NLog" Version="5.0.0-beta07" />
    <PackageReference Include="NLog.Extensions.Logging" Version="1.0.0-rtm-beta4" />
```

Uff well, I spent 40 minutes actually finding out which versions to install and how. Using only command line and VS Code was 'confusing'.

Configuring NLog

```
ï»¿<?xml version="1.0" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <targets>
    <target name="file" xsi:type="File"
        layout="${longdate} ${logger} ${message}"
        fileName="${basedir}/logs/${shortdate}.txt"
       />
  </targets>

  <rules>
    <logger name="*" minlevel="Info" writeTo="file" />
  </rules>
</nlog>
```

This config provides a rolling file based on date.

Adding endpoint that exposes logs from memory ( usefull for development later on not needed ).
- endpoint with logs from last minutes ?

We added logs to one instance of a service. Working with monolithic app having one process or even multiple ones it was simple to 'aggregate' logs. You just put them on the machine. With distributed world and multiple services working as a standalone software aggregating logs is a bit more complicated. There is no single machine that you can go to and check all the logs. You need something that will do it for yourself.

One solution is to write your own logging service that will do it for you. Fortunately there is a better way. There are solutin Out of box that are providing such capabilities.

Small List:

*
*
*


#### Healtheck

If my app was also synchronous then a lot of problems were pretty easy to test. Just make a request and check if something is not failing. Somewhere down the line if some part of the system is broken, I would get an exception.

Working with monolithic synchronous apps, I got used to a typical way of making sure the product is stable. Some logging framework, rules, rolling logs to analyze problems and maybe some alert based software that is triggered by these logs.

Network Layer that can cause problems, multiple machines problems

In the microservices-a lot of things work in a distributed fashion. It is important to identify if the distributed application is stable or not.

- What is healthcheck?

- How to define it?
- It is important to standarise healthc checks around company
 - to enable writing tooling that is able to read our services and how those respond
 - worst case scenario is services implemented with different standard and you either have to change them or create a super generic tool which is a waste of time
 - it is better to establish commont patterns and ideas what healthcheck is to avoid this problem altogether

- Simple heatlth check definiton

- examples of scenarios and consumers and meta data that might be usefull

```
json schema adefining simple healthcheck with possibility of extension
```

I could write a separate blog post on how to design healthceck response withing the org.

<another post using WeaveCloud - apm tool - ask WeaveCloud what they can give you>
<ask graphite hosted what they can give you>

#### New Yeoman generator to generate 

- logs, healtcheck + various comments

While doing this I also created new yeoman generators.

* micro-core

```
npm install microcore-generator
```

to use it just do

```
yo microcore
```

Those will evolved while doing this course.

TODO:
- links to repo and code with commits explaining the whoel process
- webinar

[0]: https://github.com/OmniSharp/generator-aspnet
[1]: https://chocolatey.org/install
[2]: https://chocolatey.org/packages/nodejs.install
[3]: http://cmder.net/
[4]: https://conemu.github.io/
[5]: http://babun.github.io/
[6]: https://github.com/dotnet/cli
[8]: .NET core cli
