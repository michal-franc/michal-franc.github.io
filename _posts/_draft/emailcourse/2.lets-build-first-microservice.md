Last lesson was all about theory. Time to do something more practical. Code!

In this lesson we will answer the most important question - What is a Microservice? We will also build one. There is a healthy mix of theory and practice.

I do encourage you to use console as much as possible as this course is optimized with this approach. All the examples are being done and tested by me on a machine running 'Linux Mint with I3'. If you want to check my setup - [dotfiles link here][11]

.NET Core has a good SDK that enables us to work from the terminal. Microsoft also replaced templating engine with their own solution. Previously they used yeoman. It wasn't bad, not sure why they have reinvented the wheel but the new generator is quite good.

You need .NET core installed on you machine, [instruction on how to install dotnet cli and sdk here.][9]

#### Linux User / Mac User

All you need to progress is installed .NET SDK and your editor of choice. Nothing else. There will be docker included in later episodes so running docker daemon and docker cli tools is also needed.

### Windows User 

Default cmd.exe in Windows is ok but it is not great. If you want to follow this course using console do yourselve a favour and install a better tool. 

* [cmder (my choice)][3]
* [ConEmu][4]

To be fair cmder is also a ConEmu as it is an extension. 

Best option for Windows is Windows 10 PRO with Hypervisor enabled. This provides a very easy to use docker environment. If you don't have Win 10 PRO you can use boot2docker solution that uses VitualBox. This approach is a bit more 'clunky' but is should be enough.

[Instructions][https://docs.docker.com/toolbox/toolbox_install_windows/]

#### IDE

I am using Visual Studio Code - highly reommended but you can use whatever editor you like. I wanted to make some magic happen with Vim but .NET support through Omnisharp is not supported on Linux Mint. Of course you can also use Visual Studio. There is also a MAC version. Just feel free to use whatever you want. Word of advice. We will use Nuget. You need to have some IDE with the support or a way to install nuget packages from the CLI.

#### Lets start coding

We will start with basic console app.

.NET SDK provide a generator. In the past Microsoft used Yeoman. Now there is a custom build tool, that works the same as Yeoman.

Run in console.

```
dotnet new
```

You should get some information back with a list of available templates. There are some available by default. You can extend this pretty easilly and add your own. As a matter of fact later in the course we will use template created by me. If you are curious - [here is the link that explains the process.][10].

Create a new folder somewhere to hold all the code for this course.

```
mkdir distributed-systems-course
cd distributed-systems-course
```

For this basic test we will run

```
mkdir distributed-systems-course
cd distributed-systems-course
dotnet new console -n micro-console -o micro-console
```
This will generate a basic console application with a name 'micro-console' in a folder 'micro-console'

We should get back info that the console app was generated. This app displays 'Hello World'. 

Using SDK we can restore all the nuget packages, build and run the app.

```
cd micro-console
dotnet restore
dotnet build
dotner run
```

Boom hello world!

#### Hello World Microservice using Asp.net Core

Time for something more complicated. Go back to main folder.

```
dotnet new webapi -n micro-web -o micro-web
```

This generates a  simple webapi app.

Once again, you know what to do.

```
dotnet restore
dotnet build
dotnet run
```

When you hit the localhost:5000 you should get a response from Kestrel server.

```
-> http lcalhost:5000

HTTP/1.1 404 Not Found
Content-Length: 0
Date: Thu, 15 Jun 2017 21:28:27 GMT
Server: Kestrel
```
PS: Important note here. I am ussing httpie to run the http request from the console. For me it is a bit better than curl. Feel free to check endpoints whatever methods suits you. It can be curls or other tool, or even browser.

This means that the app is running fine. Kestrel is a leightweight dotnet core server usefull for development. For production, I would recommend using NGinx. We will do this in future episodes.

To see some response hit

```
-> http localhost:5000/api/values

HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Thu, 15 Jun 2017 21:41:22 GMT
Server: Kestrel
Transfer-Encoding: chunked

[
    "value1", 
    "value2"
]

```

* To change port from 5000, go to Startup.cs
 
Lets stick with tradition and start with a 'Hello World'. To do this add a Controller.

```
    [Route("helloworld/")]
    public class HelloWorldController: Controller
    {
        [HttpGet]
        public string Get()
        {
            return "Hello World";
        }
    }

```

Run the app and voila we have hello world message on 'localhost:5000/hellworld'

And this is it!. You have just created your first microservice. Really this could be potentially as simple as that. There is no other magic in it. Sure, as we move on further, there will be more knowledge. On the most basic level Microservice is just a services that does something and runs standalone. 

#### So it is really a Microservice?

Yup, you just build one. But what they really are ?

Well it is a service that is micro .. muahahahah ... isn't that simple? Hah well it isn't. Microservice is just a nice marketing name that catched on with the community. Every innovation has it. Look at docker and containers. There were people doing this long time ago but it wasn't called container. Now we have a nice name, hype that generates visibility and demand.

For me Microservice is a tool, to build distributed systems.

Micro is a unfortuate part of the whole term, it points many people into incorrect direction (just like T in TDD, I am not gonna start this discussion here). We should forget about building huge multi feature wises monoliths and focus on build smaller components, services that can do 'one thing'. Defining one thing is difficult just like defining what is a unit in unit testing.

I like to approach 'one thing' as one functionality, one business requirement. DDD and bounded context is helpfull here. You have to remember that there are no strict rules. Your approach to Microservices might be slightly differnet. We are stll in the begginging, estabilishg patterns and tooling. It is good to experiment right now. 

It is slowly happening look at those links, people are establishing all of it at this very momemnt.

* [microservices.io][0]
* [APM tools list][1]
* [Building Microservice book][2]

#### Core Building Blocks of Microservices

Microservice might have different role, structure but there some core 'functionalities' that makes the life easier.

In next lesson we will cover three basic blocks:

* Core/Endpoint
* Logging
* HealthCheck

The rest of them lets leave them for the future. 

* Hosting
* Monitoring
* Management
* Registry

[0]: http://microservices.io/
[1]: https://stackify.com/application-performance-management-tools/
[2]: http://shop.oreilly.com/product/0636920033158.do
[3]: http://cmder.net/
[4]: https://conemu.github.io/
[5]: http://babun.github.io/
[6]: https://github.com/dotnet/cli
[9]: https://www.microsoft.com/net/core
[10]: https://rehansaeed.com/custom-project-templates-using-dotnet-new/
[11]: https://github.com/michal-franc/dotfiles
