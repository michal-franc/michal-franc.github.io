---
layout: post
title: Edytowalny ListBox
date: 2010-02-20 19:07:29.000000000 +00:00
categories: []
tags:
- ".net"
- c#
- visual studio
status: publish
type: post
published: true
meta:
  dsq_thread_id: '359139983'
  _edit_last: '1'
author:
  login: LaM
  email: lam.michal.franc@gmail.com
  display_name: Michal Franc
  first_name: Michal
  last_name: Franc
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>Dużo czasu spędzam ostatnio przy mini projekcicku [więcej info wkrótce]. Potrzebowałem kontrolki listboxa ale z edytowalnymi polami.<br />
Jako że w .necie taka kontrolka nie jest dostępna standardowo to postanowiłem "wyciosać" własną. .Net daje nam spore pole do popisu jeżeli chodzi o tworzenie własnych "customowych" kontrolek.</p>
<p>By tego dokonać będziemy potrzebować dwóch nowych kontrolek.</p>
<ul>
<li><span style="color: #ffff00;">TextBoxa  który będzie komunikował się z danymi ListBoxa</span></li>
<li><span style="color: #ffff00;"> ListBoxa wykorzystującego tego TextBoxa</span></li>
</ul>
<p><!--more--></p>
<h2 style="text-align: left;"><span style="color: #ffff00;">Opis Działania.</span></h2>
<p>ListBox normalnie wyświetli Itemy. W momencie wybrania któregoś pola w miejscu Itema wygeneruje odpowiednią kontrolkę TextBoxa. Po wprowadzeniu textu do TextBoxa będzie on znikał i tracił "focus" przesyłając zmiany do ListBoxa , [ skupienie :D jak to dziwnie brzmi ostatnio zauważyłem że niektóre wydawnictwa tłumaczą "singleton" jako "samotnik" ].</p>
<p><a href="http://lammichalfranc.files.wordpress.com/2010/02/edytowalny-listbox-test.jpg"><img class="aligncenter size-full wp-image-332" title="Edytowalny ListBox Test" src="assets/edytowalny-listbox-test.jpg" alt="" width="450" height="158" /></a></p>
<h2><span style="color: #ffff00;">TextBox</span></h2>
<p>Zaczniemy od TextBoxa bo zawiera on mniej modyfikacji.</p>
<pre class="lang:default decode:true ">class EdditableTextBox : TextBox
{
   private int _index = -1;

   public int Index
   {
    set { _index = value; }
   }
...</pre>
<p>&nbsp;</p>
<p>Dziedziczymy po standardowum TextBoxie i definiujemy pole Index , które będzie zawierać numer naszego obiektu , itemu , w listBoxie.</p>
<pre class="lang:default decode:true ">protected override void OnLeave(EventArgs e)
{
   ((ListBox)this.Parent).Items[_index] = this.Text;
   base.OnLeave(e);
}</pre>
<p>&nbsp;</p>
<p>Przeciążamy metodę wywoływaną w momencie wychodzenia z textBoxa tak by wszelkie wprowadzone zmiany zmieniały także obiekt w naszym ListBoxie do tego jest nam potrzebny parametr <strong>Index</strong> , który określa do którego konkretnie elementu się odnosimy.Odwołanie do ListBoxa realizujemy poprzez propercje Parent.</p>
<p>Na wszelki wypadek wywołujemy bazową metodę.</p>
<p>Można oczywiście zrobić inny mechanizm. Np akceptowanie zmian w momencie wciśnięcia odpowiegniego klawisza.</p>
<pre class="lang:default decode:true ">protected override void OnKeyPress(KeyPressEventArgs e)
{
   if (e.KeyChar == (char)Keys.Enter)
   {
      ((ListBox)this.Parent).Items[_index] = this.Text;
   }
   base.OnKeyPress(e);
}</pre>
<p>&nbsp;</p>
<p>W tym przypadku <strong>Enter</strong></p>
<h2><span style="color: #ffff00;">ListBox</span></h2>
<p>Przejdzmy teraz do ListBoxa. Tutaj już będzie troszeczkę więcej zmian.</p>
<pre class="lang:default decode:true ">class EdditableListBox : ListBox
{
      private static int MarginBeetwenItems = 5;
      private EdditableTextBox tbox;</pre>
<p>&nbsp;</p>
<p>Dziedziczymy po ListBoxie tworzymy propercje oznaczającą odstęp pomiędzy wyświetlanymi itemamy i tworzymy lokalna kopię naszego zmodyfikowanego TextBoxa</p>
<pre class="lang:default decode:true ">public EdditableListBox()
{
   tbox = new EdditableTextBox();
   tbox.Hide();
   tbox.Parent = this;
   Controls.Add(tbox);
}</pre>
<p>&nbsp;</p>
<p>Tworzymy Text Boxa ustawiamy jego "rodzica" . Propercja <strong>Parent</strong> będzie nam służyła do komunikacji pomiędzy TextBoxem i ListBoxem.</p>
<pre class="lang:default decode:true ">protected override void OnDrawItem(DrawItemEventArgs e)
{
   if (e.Index &gt; -1)
   {
        string s = Items[e.Index].ToString();

        Rectangle rect = new Rectangle(
        e.Bounds.X, e.Bounds.Y + (e.Index * MarginBeetwenItems),
        e.Bounds.Width, e.Bounds.Height);

        e.Graphics.DrawString(s, Font, new SolidBrush(SystemColors.WindowText), rect);
    }
}</pre>
<p>&nbsp;</p>
<p>Musimy przeciążyć metodę odrysowywującą. Na wszelki wypadek badamy index Obiektu w ListBoxie , wyznaczamy prostokąt na podstawie jego parametrów , uwzględniając<br />
<strong>MarginBeetwenItems</strong>. Rysujemy napis w odpowiednim miejscu.</p>
<pre class="lang:default decode:true ">protected override void OnMouseUp(MouseEventArgs e)
{
     int index = IndexFromPoint(e.X, e.Y);

     if (index != ListBox.NoMatches &amp;&amp; index != 65535)
     {
          if (e.Button == MouseButtons.Left)
          {
               string s = Items[index].ToString();
               Rectangle rect = GetItemRectangle(index);

               tbox.Location = new Point(rect.X, rect.Y + (index * MarginBeetwenItems));
               tbox.Size = new Size(rect.Width, rect.Height);
               tbox.Text = s;
               tbox.Index = index;
               tbox.SelectAll();
               tbox.Show();
               tbox.Focus();
          }
     }

     base.OnMouseUp(e);
}</pre>
<p>&nbsp;</p>
<p>Główna metoda tworząca [chociaż bardziej pasuje słowo modyfikująca] odpowiednio kontrolke TextBoxa , przy kliknięciu Lewym Przyciskiem myszki. Parametry TextBoxa modyfikujemy tak aby wyświetlał się w miejscu klikniętego obiektu na ListBoxie.</p>
<pre class="lang:default decode:true ">protected override void OnSelectedIndexChanged(EventArgs e)
{
      tbox.Hide();
      base.OnSelectedIndexChanged(e);
}

protected override void OnLeave(EventArgs e)
{
      tbox.Hide();
      base.OnLeave(e);
}</pre>
<p>&nbsp;</p>
<p>Odpowiednie funkcje powodujące zniknięcie naszego TextBoxa przy wyjściu z kontrolki i przy zmianie obiektu.</p>
