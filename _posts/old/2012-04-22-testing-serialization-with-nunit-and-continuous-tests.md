---
layout: post
title: Testing Serialization with NUnit and Continuous Tests
date: 2012-04-22 21:25
author: Michal Franc
comments: true
categories: []
tags: [tdd, archive]
---
<p>In this post I want to present a solution that, I am using to test serialization in one of my projects. This project is a <strong>web application</strong> and a lot of communication is performed through <strong>JSON</strong> formatted messages. It is really important to be sure if it is working. With serialization we can only find potential mistakes and errors on the runtime. By finding problems early you can eliminate more complex and costly bugs in the future. <h4>Json Serialization</h4> <p>For serialization, I am using <a href="http://nuget.org/packages/newtonsoft.json"><strong>Json.Net</strong></a><strong>&nbsp;</strong>it is quite popular and stable library. All my objects that are being serialized, implement <strong>IJsonable </strong>interface. This gives me easy way to find and check if particular class is serialized somewhere.&nbsp; It is very important information. At my company we had recently problem with some objects because someone wasn’t sure if one of the class is serialized or not. This caused some “unsupported” behavior on the server that was desterilizing data. <p><a href="http://www.mfranc.com/wp-content/uploads/2012/04/image8.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="image" border="0" alt="image" src="http://www.mfranc.com/wp-content/uploads/2012/04/image_thumb8.png" width="244" height="84"></a>&nbsp; <p>This interface contains only one method returning just object. With this solution, I can return either <strong>anonymous type</strong> or another class, typically <strong>DTO ( Data Transfer Object )</strong> that contains only simple easily serialized data (eg. <strong>Value Types </strong>). <h5>Example:</h5> <p><a href="http://www.mfranc.com/wp-content/uploads/2012/04/image9.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="image" border="0" alt="image" src="http://www.mfranc.com/wp-content/uploads/2012/04/image_thumb9.png" width="418" height="327"></a>  <p>This is quite simple model. It contains four simple types and <strong>DashBoardControlType, </strong>it<strong> </strong>is just an <strong>Enum</strong>. Method<strong> </strong><strong>ToJson() </strong>is used to create anonymous object. In this example I am creating anonymous type. <p><a href="http://www.mfranc.com/wp-content/uploads/2012/04/image10.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="image" border="0" alt="image" src="http://www.mfranc.com/wp-content/uploads/2012/04/image_thumb10.png" width="488" height="28"></a>  <p>This object is then used with <strong>Json.Net </strong>library to create <strong>JSON</strong> string. <p>One of the problems with serialization is that errors are noticed on the runtime. If my program compiles it doesn’t mean that I won’t have any problems. One of the common mistakes in classes being serialized, is too complex logic. For instance one class can have some value dependent on some external dependency. Creator of this class assumed that it will be serialized only in context that has connection to this dependency. Someone without broad knowledge of the system could forget about this and use this class in another context that is lacking access to it. <p>Good example of that kind of situation is accessing <strong>State</strong> of the application through the <strong>HttpContext. </strong>Our class has a property that on the get method is accessing <strong>HttpContext. </strong>I won’t see the problem if class will be used in my scenario, but later if someone will try to serialize this class in other environment that doesn’t have access to the <strong>HttpContext, </strong>a null reference exception will be thrown. It is really important to test if this kind of situation happens. To check it, I am using very simple test. <h4>Testing Serialization</h4> <p>Let's discuss this simple test procedure.</p> <p><a href="http://www.mfranc.com/wp-content/uploads/2012/04/image12.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://www.mfranc.com/wp-content/uploads/2012/04/image12_thumb.png" width="667" height="358"></a> </p> <p>With <strong>IJsonable </strong>interface and reflection, I can easily obtain all the types of the classes to test. Simple <strong>Linq</strong> query filters out all the classes in specified assembly, within specified namespace with defined <strong>IJsonable </strong>interface. Then for each class <strong>Activator </strong>is used to create instance of the class. Newly created object is serialized and If there is an error, name of the type is added to the list.  <p>This test is using <strong>NUnit </strong>framework<strong>. </strong>Unit test runner provides perfect environment, that lacks all dependencies, so there will be errors if someone makes a class that will for example access <strong>HttpContext </strong>directly.  <p>With this simple check we can almost be sure that we won’t get any stupid errors and we can easily see that something is wrong with our model. <h4>Continuous Tests</h4> <p>Running tests each time, I am making a change can become … pain in … <img style="border-bottom-style: none; border-left-style: none; border-top-style: none; border-right-style: none" class="wlEmoticon wlEmoticon-smilewithtongueout" alt="Smile with tongue out" src="http://www.mfranc.com/wp-content/uploads/2012/04/wlEmoticon-smilewithtongueout.png"> With <strong>Resharper</strong> it is much easier, but still sometimes I will forget to do this and then beautiful message from our Jenkins server will notify me about some fail. It would be a lot better if this information would be instant. There is a solution to this called <strong>Continuous Tests. </strong> <p>I started using <strong><a href="http://continuoustests.com/">Mighty Moose</a></strong> recently. It is a plugin to <strong>Visual Studio </strong>that creates a test runner in the background. This runner analyses all the changes made in the code and on simple <strong>CTRL+S (Save) ,</strong>if it detects that recent change in the code affects tests, lined test will be executed automatically.  <p>For example in serialization logic, discussed in this post, this kind of instant information can be critical. Each time I change something in the model ( some property for example ). Test is performed automatically and I will get information if this works or not. This is even better in situation when one of my colleagues is changing something inside my code. He won’t be always aware that this code is covered by unit tests, and Continuous Tests runner will notify him about this and also will inform him automatically if this change is failing tests.</p>
